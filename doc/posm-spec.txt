A Plain Old Stack Machine (POSM)
================================

This document describes a Plain Old Stack Machine (POSM) intended to
be used in experiments with different types of thread scheduling
algorithms. POSM sports the following instructions: PUSH, PUSHR, POP,
DUP, SWAP, LOADR, STORER, MOVER, ADD, SUB, MUL, DIV, JUMP, CJUMP,
CALL, RET, SYSCALL, AND, OR, NOT, EQ, NEQ, LT, GT, NOP and HALT.

POSM also has three registers:

SP: Stack pointer
FP: Frame pointer
PC: Program counter

POSM exposes these registers to make management of call stacks
explicit. This has drawbacks in terms of efficiency but makes it
easy to experiment with different kinds of stack framing policies and
more.

A number of the above instructions can actually be implemented in
terms of changes to these registers. Minimalism must not be taken to
an extreme though.

NOTE: The stack grows downwards.

Instruction set
===============

LABEL label       ; A jump label. This is a meta instruction.
PUSH value        ; Pushes a value onto the stack.
PUSHR SP|FP|PC    ; Pushes the content of a register onto the stack.
POP               ; Removes the top value from the stack.
DUP               ; Duplicates the top value on the stack.
SWAP              ; Swaps the top two values on the stack.
LOADR SP|FP       ; Copies a value on the stack to the top of the stack.
                  ; The top value of the stack must be an offset to SP
                  ; or FP
STORER SP|FP      ; Updates a value on the stack. The top value of the
                  ; stack must an offset to the SP or FP and the new
                  ; value comes next.
MOVER SP|FP|PC    ; Pops the top of the stack and copies the value to
                  ; a register.
ADD               ; Pops two values, adds them, and pushes the result.
SUB               ; Pops two values, subtracts them, and pushes the result.
MUL               ; Pops two values, multiplies them, and pushes the result.
DIV               ; Pops two values, divides them, and pushes the result.
JUMP label        ; Unconditionally jumps to a label.
CJUMP label       ; Conditionally jumps based to a label if the top
                  ; value of the stack is not 0. Pops the top value.
CALL label        ; Calls a function and pushes the return address.
RET               ; Returns from a function, i.e. pops the return
                  ; address and sets PC to its value.
SYS name          ; Calls a built-in function, e.g. spawn, send, recv,
                  ; rand, sleep and println etc.
AND               ; Pops two values, performs a logical AND, and
                  ; pushes the result.
OR                ; Pops two values, performs a logical OR, and
                  ; pushes the result.
NOT               ; Pops two values, performs a logical NOT, and
                  ; pushes the result.
EQ                ; Pops two values, checks if they are equal, and
                  ; pushes the result (0 or 1).
NEQ               ; Pops two values, checks if they are not equal, and
                  ; pushes the result (0 or 1).
LT                ; Pops two values, checks if the first is less than
                  ; the second, and pushes the result (0 or 1).
GT                ; Pops two values, checks if the first is greater than
                  ; the second, and pushes the result (0 or 1).
NOP               ; No operation. Do nothing.
HALT              ; Halts the stack machine execution.

Call stack
==========

Explicit call stack management means that each function must govern
its stack frame with careful updates of SP, FP and more.

The CALL instruction pushes a return address on the stack (to be used
by RET later on) and the function typically stores the previous FP
on its stack frame and updates FP to SP, i.e. explicitly managing
its own stack frame.

If the final action of a function is to call itself it would be a
waste of a stack frame to use a CALL instruction. Instead the current
parameters can be updated inline followed by a plain JUMP back to itself.

Example 1
=========

Consider this Erlang snippet:

start() ->
    summer(13, 10).

summer(_M, 0) ->
    0;
summer(M, N) ->
    M + summer(M, N - 1).

This is how it could be written:

__EXAMPLE1_START__
LABEL 0          ; start/0
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ; Call summer(13, 10)
  PUSH 13        ; Pushes parameter M
  PUSH 10        ; Pushes parameter N
  PUSH 2         ; Pushes number of parameters
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   13
  ;;   10
  ;;   2
  CALL 1
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   130
  RET

LABEL 1          ; summer/2
  ;; Stack:
  ;;   M
  ;;   N
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ; Is it summer(_M, 0) clause?
  PUSH 3
  LOADR FP       ; Parameter  N
  PUSH 0
  NEQ
  CJUMP 2
  PUSH 0
  ;; Stack:
  ;;   M
  ;;   N
  ;;   Number of parameters
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   0
  RET

LABEL 2
  ;; Stack:
  ;;   M
  ;;   N
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ; It is summer(M, N) clause!
  ; Call summer(M, N - 1)
  PUSH 4
  LOADR FP       ; Parameter M
  PUSH 4
  LOADR FP       ; Pushes Parameter M
  PUSH 3
  LOADR FP       ; Parameter N
  PUSH 1
  SUB            ; Pushes parameter N - 1
  PUSH 2         ; Pushes number of parameters
  ;; Stack:
  ;;   M
  ;;   N
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   M
  ;;   N - 1
  ;;   2
  CALL 1
  ;; Stack:
  ;;   summer(M, N - 1)
  ADD            ; M + summer(M, N - 1)
  ;; Stack:
  ;;   M
  ;;   N
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   M + summer(M, N - 1)
  RET
__EXAMPLE1_END__

Example 2
=========

Consider this Erlang snippet:

start() ->
    summer(13, 10, 0).

summer(_M, 0, Ack) ->
    Ack;
summer(M, N, Ack) ->
    summer(M, N - 1, Ack + M).

It does the same as the example above but with an accumulated
parameter. This makes the function tail recursive, i.e. the stack
frame can be reused for each recursion and the call stack will not
grow. To achieve this a CALL is not used. Instead parameters are
updated in the current stack frame and then a plain JUMP is done to
perform next iteration.

This is how it could be written:

__EXAMPLE2_START__
LABEL 0          ; start/0
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ; Call summer(13, 10)
  PUSH 13       ; Pushes parameter M
  PUSH 10       ; Pushes parameter N
  PUSH 0        ; Pushes parameter Ack
  PUSH 3        ; Pushes number of parameters
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   13
  ;;   10
  ;;   0
  ;;   3
  CALL 1
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   130
  RET

LABEL 1          ; summer/2
  ;; Stack:
  ;;   M
  ;;   N
  ;;   Ack
  ;;   3 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ; Is it summer(_M, 0, Ack) clause?
  PUSH 4
  LOADR FP       ; Parameter N
  PUSH 0
  NEQ
  CJUMP 2
  PUSH 3
  LOADR FP
  ;; Stack:
  ;;   M
  ;;   N
  ;;   Ack
  ;;   3 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   Ack
  RET

LABEL 2
  ;; Stack:
  ;;   M
  ;;   N
  ;;   Ack
  ;;   3 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ; It is summer(M, N, Ack)!
  ; Call summer(M, N - 1, Ack + M)
  PUSH 4
  LOADR FP       ; Parameter N
  PUSH 1
  SUB            ; N - 1
  PUSH 3
  LOADR FP       ; Parameter Ack
  PUSH 5
  LOADR FP       ; Parameter M
  ADD
  ;; Stack:
  ;;   M
  ;;   N
  ;;   Ack
  ;;   3 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   N - 1
  ;;   Ack + M
  ; Patch (changed) parameters in place and jump to label 1
  PUSH 3
  STORER FP      ; Patches Ack -> Ack + M
  PUSH 4
  STORER FP      ; Patches N -> N - 1
  ;; Stack:
  ;;   M
  ;;   N - 1
  ;;   Ack + M
  ;;   3 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  JUMP 1         ; Voila! The old stack frame is reused.
__EXAMPLE2_END__

Example 3
=========

Consider this Erlang snippet:

THIS EXAMPLE IS NOT RIGHT. EXPERIMANTATION!!!

start() ->
    X = 1,
    Y = "foo",
    Z = X + 1,
    bar(Y, Z).

bar(Y, Z) ->
    io:format("~s\n", [Y]),
    Z.

Yet another silly example introducing how to deal with local
variables, string literals and the SYS instruction.

__EXAMPLE3_START__
LABEL 0          ; start/0
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  PUSH 1         ; X = 1
  ALLOC "foo"    ; Y = "foo"
  PUSH -1
  LOADR FP
  PUSH 1
  ADD            ; Z = X + 1
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   1 (X)
  ;;   An address to "foo" (Y)
  ;;   Z = X + 1
  ; Call bar(Y, Z)
  PUSH -2
  LOADR FP       ; Pushes local variable Y
  PUSH -3
  LOAD FP        ; Pushes local variable Z
  PUSH 2         ; Pushes number of parameters
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   1 (X)
  ;;   An address to "foo" (Y)
  ;;   Z = X + 1
  ;;   An address to "foo" (Y)
  ;;   Z = X + 1
  CALL 1
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   1 (X)
  ;;   An address to "foo" (Y)
  ;;   Z = X + 1
  ;;   Z = X + 1 ; Return value from bar/2
  ; Remove local variables
  SWAP
  POP            ; Pop local variable Z
  SWAP
  FREE           ; Pop local variable Y and free memory
  SWAP
  POP            ; Pop local variable X
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   Z = X + 1 ; Return value from bar/2
  RET

LABEL 1          ; bar/2
  ;; Stack:
  ;;   Y
  ;;   Z
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ; Call SYS println
  PUSH 2
  LOADR FP       ; Pushes parameter Y
  ;; Stack:
  ;;   Y
  ;;   Z
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   Y
  SYS println
  ;; Stack:
  ;;   Y
  ;;   Z
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   1
  POP            ; Pops return value from println
  PUSH 3
  LOADR FP
  ;; Stack:
  ;;   Y
  ;;   Z
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   Z
  RET
__EXAMPLE3_END__
