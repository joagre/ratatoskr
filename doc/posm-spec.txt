A Plain Old Stack Machine (POSM)
================================

This document describes a Plain Old Stack Machine (POSM) intended to
be used in experiments with different types of thread scheduling
algorithms. POSM sports the following instructions: PUSH, PUSHR, POP,
DUP, SWAP, LOAD, STORE, ADD, SUB, MUL, DIV, JUMP, CJUMP, CALL, RET,
SYSCALL, AND, OR, NOT, EQ, NEQ, LT, GT, NOP and HALT.

POSM also has two read-only registers:

SP: Stack pointer
FP: Frame pointer

NOTE: The stack grows downwards.

Instruction set
===============

LABEL label       ; A jump label. This is a meta instruction.
PUSH value        ; Pushes a value onto the stack.
POP               ; Removes the top value from the stack.
DUP               ; Duplicates the top value on the stack.
SWAP              ; Swaps the top two values on the stack.
LOAD SP|FP        ; Copies a value on the stack to the top of the stack.
                  ; The top value of the stack must be an offset to SP
                  ; or FP
STORE SP|FP       ; Updates a value on the stack. The top value of the
                  ; stack must an offset to the SP or FP and the new
                  ; value comes next.
ADD               ; Pops two values, adds them, and pushes the result.
SUB               ; Pops two values, subtracts them, and pushes the result.
MUL               ; Pops two values, multiplies them, and pushes the result.
DIV               ; Pops two values, divides them, and pushes the result.
JUMP label        ; Unconditionally jumps to a label.
CJUMP label       ; Conditionally jumps based to a label if the top
                  ; value of the stack is not 0. Pops the top value.
CALL label arity  ; Calls a function implemented in label with the
                  ; specified arity. Pushes the return address and
                  ; previous FP onto the stack. Sets FP to the first
                  ; parameter on the stack.
RET               ; Removes the stack frame as specified by FP
                  ; (everything below FP is nuked). Restores FP to the
                  ; previous FP. Pushes the return value onto the stack and
                  ; jumps to the return address.
SYS name          ; Calls a built-in function, e.g. spawn, send, recv,
                  ; rand, sleep and println etc.
AND               ; Pops two values, performs a logical AND, and
                  ; pushes the result.
OR                ; Pops two values, performs a logical OR, and
                  ; pushes the result.
NOT               ; Pops two values, performs a logical NOT, and
                  ; pushes the result.
EQ                ; Pops two values, checks if they are equal, and
                  ; pushes the result (0 or 1).
NEQ               ; Pops two values, checks if they are not equal, and
                  ; pushes the result (0 or 1).
LT                ; Pops two values, checks if the first is less than
                  ; the second, and pushes the result (0 or 1).
GT                ; Pops two values, checks if the first is greater than
                  ; the second, and pushes the result (0 or 1).
NOP               ; No operation. Do nothing.
HALT              ; Halts the stack machine execution.

Example 1
=========

Consider this Erlang snippet:

start() ->
    summer(13, 10).

summer(_M, 0) ->
    0;
summer(M, N) ->
    M + summer(M, N - 1).

This is how it could be written:

__EXAMPLE1_START__
LABEL 0          ; start/0
  ;; Stack:
  ;;   Return address <- FP
  ;;   Previous FP
  ; Call summer(13, 10)
  PUSH 13        ; Pushes parameter M
  PUSH 10        ; Pushes parameter N
  ;; Stack:
  ;;   Return address <- FP
  ;;   Previous FP
  ;;   13
  ;;   10
  CALL 1 2
  ;; Stack:
  ;;   Return address <- FP
  ;;   Previous FP
  ;;   130
  RET
  ;; Stack:
  ;;   130

LABEL 1          ; summer/2
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Return address
  ;;   Previous FP
  ; Is it summer(_M, 0) clause?
  PUSH -1
  LOAD FP       ; Parameter  N
  PUSH 0
  NEQ
  CJUMP 2
  PUSH 0
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Return address
  ;;   Previous FP
  ;;   0
  RET
  ;; Stack:
  ;;   0

LABEL 2
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Return address
  ;;   Previous FP
  ; It is summer(M, N) clause!
  ; Call summer(M, N - 1)
  PUSH 0
  LOAD FP       ; Parameter M
  PUSH 0
  LOAD FP       ; Pushes Parameter M
  PUSH -1
  LOAD FP       ; Parameter N
  PUSH 1
  SUB            ; Pushes parameter N - 1
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Return address
  ;;   Previous FP
  ;;   M
  ;;   N - 1
  CALL 1 2
  ;; Stack:
  ;;   summer(M, N - 1)
  ADD            ; M + summer(M, N - 1)
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Return address
  ;;   Previous FP
  ;;   M + summer(M, N - 1)
  RET
  ;; Stack:
  ;;   M + summer(M, N - 1)
__EXAMPLE1_END__

Example 2
=========

Consider this Erlang snippet:

start() ->
    summer(13, 10, 0).

summer(_M, 0, Ack) ->
    Ack;
summer(M, N, Ack) ->
    summer(M, N - 1, Ack + M).

It does the same as the example 1 but with an accumulated
parameter. This makes the function tail recursive, i.e. the stack
frame can be reused for each recursion and the call stack will not
grow. To achieve this a CALL is not used. Instead parameters are
patched in the current stack frame and then a plain JUMP is done to
perform next iteration.

This is how it could be written:

__EXAMPLE2_START__
LABEL 0          ; start/0
  ;; Stack:
  ;;   Return address <- FP
  ;;   Previous FP
  ; Call summer(13, 10)
  PUSH 13       ; Pushes parameter M
  PUSH 10       ; Pushes parameter N
  PUSH 0        ; Pushes parameter Ack
  ;; Stack:
  ;;   Return address <- FP
  ;;   Previous FP
  ;;   13
  ;;   10
  ;;   0
  CALL 1 3
  ;; Stack:
  ;;   Return address <- FP
  ;;   Previous FP
  ;;   130
  RET
  ;; Stack:
  ;;   130

LABEL 1          ; summer/2
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Ack
  ;;   Return address
  ;;   Previous FP
  ; Is it summer(_M, 0, Ack) clause?
  PUSH -1
  LOAD FP        ; Parameter N
  PUSH 0
  NEQ
  CJUMP 2
  PUSH -2
  LOAD FP        ; Ack
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Ack
  ;;   Return address
  ;;   Previous FP
  ;;   Ack
  RET
  ;; Stack:
  ;;   Ack

LABEL 2
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Ack
  ;;   Return address
  ;;   Previous FP
  ; It is summer(M, N, Ack)!
  ; Call summer(M, N - 1, Ack + M)
  PUSH -1
  LOAD FP        ; Parameter N
  PUSH 1
  SUB            ; N - 1
  PUSH -2
  LOAD FP        ; Parameter Ack
  PUSH 0
  LOAD FP        ; Parameter M
  ADD
  ;; Stack:
  ;;   M <- FP
  ;;   N
  ;;   Ack
  ;;   Return address
  ;;   Previous FP
  ;;   N - 1
  ;;   Ack + M
  ; Patch (changed) parameters in place and jump to label 1
  PUSH -2
  STORE FP      ; Patches Ack -> Ack + M
  PUSH -1
  STORE FP      ; Patches N -> N - 1
  ;; Stack:
  ;;   M <- FP
  ;;   N - 1
  ;;   Ack + M
  ;;   Return address
  ;;   Previous FP
  JUMP 1         ; Voila! The old stack frame is reused.
__EXAMPLE2_END__

Example 3
=========

Consider this Erlang snippet:

start() ->
    X = 1,
    Y = "foo",
    Z = X + 1,
    bar(Y, Z).

bar(Y, Z) ->
    io:format("~p\n", [Z]),
    Y.

This rather silly example introduces how to deal with local variables,
string literals and the SYS instruction.

__EXAMPLE3_START__
LABEL 0          ; start/0
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  PUSH 1         ; Local variable X
  PUSH "foo"     ; Local variable Y
  PUSH -1
  LOADR FP
  PUSH 1
  ADD            ; Local variable Z
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   1 (Local variable X)
  ;;   "foo" (Local variable Y [Copy N in data stack])
  ;;   2 (Local variable Z)
  ; Call bar(Y, Z)
  PUSH -2
  LOADR FP       ; Pushes parameter Y
  PUSH -3
  LOAD FP        ; Pushes parameter Z
  PUSH 2         ; Pushes number of parameters
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   1 (Local variable X)
  ;;   "foo" (Address N in data stack)
  ;;   2 (Local variable Z)
  ;;   "foo"  (Address N+1 in data stack)
  ;;   2 (Z)
  ;;   2 (Number of parameters)
  CALL 1
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   1 (Local variable X)
  ;;   The address to "foo" (Local variable Y)
  ;;   2 (Local variable Z)
  ;;   The address to "foo" (-> address N+2. Return value from bar/2)
  ; Remove local variables
  SWAP
  POP            ; Pop local variable Z
  SWAP
  FREE
  POP            ; Pop local variable Y (address N in data stack)
  SWAP
  POP            ; Pop local variable X
  ;; Stack:
  ;;   0 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   The address to "foo" (-> address N+2. Return value from bar/2)
  RET
  ;; Stack:
  ;;   The address to "foo" (Return value from bar/2)

LABEL 1          ; bar/2
  ;; Stack:
  ;;   Y
  ;;   Z
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ; Call SYS println
  PUSH 3
  LOADR FP       ; Pushes parameter Z
  SYS println
  ;; Stack:
  ;;   Y
  ;;   Z
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   1 (Return value from println)
  POP            ; Pops return value from println
  PUSH 4
  LOADR FP       ; Result
  ;; Stack:
  ;;   Y
  ;;   Z
  ;;   2 (number of parameters)
  ;;   Return address
  ;;   Previous FP <- FP
  ;;   Y
  RET
  ;; Stack:
  ;;   Y
__EXAMPLE3_END__
