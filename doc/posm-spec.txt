# The Plain Old Stack Machine (POSM)

Here follows a description of the Plain Old Stack Machine (POSM) and
its (not so surprising) instructions: push, pushs, pop, dup, swap,
load, store, add, sub, mul, div, jump, cjump, call, ret, sys, and, or,
not, eq, neq, lt, gt, nop and halt.

POSM also has two read-only registers:

sp: Stack pointer
fp: Frame pointer

NOTE: The stack grows downwards.

Instruction set
===============

label label       ; A jump label. This is a meta instruction.
push value        ; Pushes a value onto the stack.
pushs <string>    ; Pushes a string value onto the stack.
pop               ; Removes the top value from the stack.
dup               ; Duplicates the top value on the stack.
swap              ; Swaps the top two values on the stack.
load sp|fp        ; Copies a value from the stack, using a relative
                  ; sp or fp offset, to the top of the stack. The
                  ; offset is expected to be on the stack.
store sp|fp       ; Updates a value on the stack using a relative sp
                  ; or fp offset. The new value and the offset are
                  ; expected to be on the stack.
                  ; from the stack.
add               ; Pops two values, adds them, and pushes the result.
sub               ; Pops two values, subtracts them, and pushes the result.
mul               ; Pops two values, multiplies them, and pushes the result.
div               ; Pops two values, divides them, and pushes the result.
jump label        ; Unconditionally jumps to a label.
cjump label       ; Conditionally jumps to a label if the top value of
                  ; the stack is not 0.
call label arity  ; Calls a function located in label with the
                  ; specified arity. Pushes the return address and
                  ; previous fp onto the stack. Sets fp to the first
                  ; parameter on the stack. The arity corresponds with
                  ; the number of parameters.
mcall             ; Works as "call" but label and arity (and more) are
                  ; expected to be on the stack in the is order arity
                  ; number of parameters, the arity, the string module
                  ; name and the label. The module is loaded
                  ; automatically and after that the same thing
                  ; happens as described for "call".
ret [copy]        ; Removes the call stack frame, i.e. everything
                  ; below fp is nuked, and does the same for the data
                  ; stack. Restores fp to the previous fp for both
                  ; stacks. Pushes the return value onto the callers
                  ; call stack. The copy operand is only meaningful if
                  ; the return value is a string, i.e. the string
                  ; return value's data is copied onto the callers
                  ; data stack. Jumps to the return address.
sys name          ; Calls a built-in function, e.g. send, recv,
                  ; println, display and exit etc.
and               ; Pops two values, performs a logical and, and
                  ; pushes the result.
or                ; Pops two values, performs a logical or, and
                  ; pushes the result.
not               ; Pops two values, performs a logical not, and
                  ; pushes the result.
eq                ; Pops two values, checks if they are equal, and
                  ; pushes the result (0 or 1).
neq               ; Pops two values, checks if they are not equal, and
                  ; pushes the result (0 or 1).
lt                ; Pops two values, checks if the first is less than
                  ; the second, and pushes the result (0 or 1).
gt                ; Pops two values, checks if the first is greater than
                  ; the second, and pushes the result (0 or 1).
nop               ; No operation. Do nothing.
halt              ; Halts the stack machine execution.
spawn label arity ; Works as "call" but spawns a new job.
mspawn            ; Works as "mcall" but spawns a new job.

Example: Hello world!
=====================

__hello_world__start__
; File: ./doc/hello_word.posm
; Run: ./d/bin/e -l ./doc hello_world 0
;
; start() ->
;     io:format("Hello world!\n").

label 0
  pushs "Hello world!"
  sys println
  ret
__hello_world__end__

Example: Factorial
==================

__fac__start__
; File: ./doc/fac.posm
; Run: ./d/bin/e -l ./doc fac 0 10
;
; fac(1) ->
;     1;
; fac(N) ->
;     N * fac(N - 1).

label 0          ; fac(1)
  push 0
  load fp        ; N
  push 1
  neq
  cjump 1
  push 1
  ret

label 1          ; fac(N)
  push 0
  load fp        ; N
  push 0
  load fp        ; N
  push 1
  sub            ; N - 1
  call 0 1       ; fac(N - 1).
  mul            ; N * fac(N - 1).
  ret
__fac__end__

Example: Factorial (tail recursive)
===================================

__tfac__start__
; File: ./doc/tfac.posm
; Run: ./d/bin/e -l ./doc tfac 0 10 1
;
; fac(N) when N >= 0 ->
;     fac(N, 1).
;
; fac(0, Acc) ->
;     Acc;
; fac(N, Acc) when N > 0 ->
;     fac(N - 1, N * Acc).

label 0          ; fac(0, Acc)
  push 0
  load fp        ; N
  push 0
  neq
  cjump 1
  push -1
  load fp        ; Acc
  ret

label 1          ; fac(N, Acc)
  push 0
  load fp        ; N
  push 1
  sub            ; N - 1
  push 0
  load fp        ; N
  push -1
  load fp        ; Ack
  mul
  push -1
  store fp       ; Replace parameter Acc
  push 0
  store fp       ; Replace parameter N
  jump 0         ; fac(N - 1, N * Acc).
__tfac__end__

Example: Dynamic code loading
=============================

__module_calls__start__
; File: ./doc/module_calls.posm
; Run: ./d/bin/e -l ./doc module_calls 0 10
;
; start(N) ->
;     io:format("~w\n", [fac:fac(N)]),
;     io:format("~w\n", [tfac:fac(N + 2)]).

label 0          ; start(N)
  push 0
  load fp        ; N
  push 1         ; Arity
  pushs "fac"    ; Module name
  push 0
  mcall          ; fac:fac(N)
  sys display
  pop
  push 0
  load fp        ; N
  push 2
  add            ; N + 2
  push 1         ; Acc
  push 2         ; Arity
  pushs "tfac"   ; Module name
  push 0         ; Label
  mcall          ; tfac:fac(N, 1)
  sys display
  ret
__module_calls__end__

Example: Concurrent Ackermann
=============================

__ackermann__start__
; File: ./doc/ackermann.posm
; Run: ./d/bin/e -l ./doc ackermann 0
; Run: ./d/bin/e -l ./doc ackermann 10
; Run: ./d/bin/e -l ./doc ackermann 1 3 6
;
; start() ->
;     ackermann(3, 6).
;
; start2() ->
;     spawn(fun() -> ackermann(3, 6) end),
;     spawn(fun() -> ackermann(3, 7) end),
;     spawn(fun() -> fac:fac(10) end).
;
; ackermann(0, N) ->
;     N + 1;
; ackermann(M, 0) when M > 0 ->
;     ackermann(M - 1, 1);
; ackermann(M, N) when M > 0, N > 0 ->
;     ackermann(M - 1, ackermann(M, N - 1)).

label 0          ; start()
  push 3         ; M
  push 6         ; N
  call 1 2       ; ackermann(3, 6)
  dup
  sys display
  pop
  ret

label 10         ; start2()
  push 3         ; M
  push 6         ; N
  spawn 1 2      ; spawn(fun() -> ackermann(3, 6) end)
  pop
  push 3         ; M
  push 7         ; N
  spawn 1 2      ; spawn(fun() -> ackermann(3, 7) end)
  pop
  push 10        ; N
  push 1         ; Arity
  pushs "fac"    ; Module name
  push 0         ; Label
  mspawn         ; spawn(fun() -> fac:fac(10) end)
  ret

label 1          ; ackermann(0, N)
  push 0
  load fp        ; M
  push 0
  neq            ; M == 0?
  cjump 2
  push -1
  load fp        ; N
  push 1
  add            ; N + 1
  ret

label 2          ; ackermann(M, 0) when M > 0
  push -1
  load fp        ; N
  push 0
  neq
  cjump 3
  push 0
  load fp        ; M
  push 0
  gt             ; M > 0 ?
  not
  cjump 3
  push 0         ; M
  load fp
  push 1
  sub            ; M - 1
  push 0
  store fp       ; Replace parameter M
  push 1
  push -1
  store fp       ; Replace parameter N
  jump 1         ; ackermann(M - 1, 1);

label 3          ; ackermann(M, N) when M > 0, N > 0
  push 0
  load fp        ; M
  push 1
  sub            ; M - 1
  push 0
  load fp        ; M
  push -1
  load fp        ; N
  push 1
  sub            ; N - 1
  call 1 2       ; ackermann(M, N - 1)
  push -1
  store fp       ; Replace parameter N
  push 0
  store fp       ; Replace parameter M
  jump 1         ; ackermann(M - 1, ackermann(M, N - 1))
__ackermann__end__
