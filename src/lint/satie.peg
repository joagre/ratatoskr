%prefix "satie"

%header {
    #include <stdarg.h>
    #include <satie_error.h>
    #include "satie_auxil.h"
    #include "symbol_table.h"
    #include "hm.h"

/*
    static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
    #define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
    if (strcmp(rule, "WS") != 0 && strcmp(rule, "_") != 0 && strcmp(rule, "__") != 0) \
        fprintf(stderr, "%*s%s %s @%zu [%.*s]\n", (int)((level) * 2), "", dbg_str[event], \
                rule, pos, (int)(length), buffer)
*/

    static int ROW = 1;

    static int satie_getchar(satie_auxil_t* _auxil) {
        int c = getchar();
        if (c == '\n') {
            ROW++;
        }
        return c;
    }

    static void panic(const char *fmt, ...) {
        va_list args;
        va_start(args, fmt);
        fprintf(stderr, "\033[31mError:\033[0m ");
        vfprintf(stderr, fmt, args);
        fprintf(stderr, "\n");
        va_end(args);
        exit(1);
    }

    static void satie_error(satie_auxil_t* auxil) {
        panic("Bailing out near line %d", ROW);
        exit(1);
    }
}

%auxil "satie_auxil_t*"
%value "ast_node_t*"

%source {
#define PCC_GETCHAR(auxil) satie_getchar(auxil)
#define PCC_ERROR(auxil) satie_error(auxil)
}

#
# Top level structure
#

Program <- _ (i:Imports __)? t:TopLevelDefs EOF { $$ = CN(PROGRAM, 2, i, t); }
TopLevelDefs <- t:TopLevelDef { $$ = CN(TOP_LEVEL_DEFS, 1, t); } (__ t:TopLevelDef { AC($$, t); } / TopLevelDefError)*
TopLevelDef <- (t:AliasDef / t:TypeDef / t:EnumDef / t:FunctionDef / t:InterfaceDef / t:ClassDef) { $$ = t; }
TopLevelDefError <- ("," / ";") {
    panic("Unexpected %s between top level definitions on line %d",
          $0, auxil->row);
}

#
# Import
#

Imports <- i:Import { $$ = CN(IMPORTS, 1, i); } (__ i:Import { AC($$, i); })*
Import <- "import" __ (ma:ModuleAlias _ "=" _)? _ m:ModuleComponents (_ ":" _ i:ImportedNames)? { $$ = CN(IMPORT, 3, ma, m, i); }
ModuleAlias <- Identifier { $$ = CT(MODULE_ALIAS, $0); }
ModuleComponents <- m:ModuleComponent {$$ = CN(MODULE, 1, m); } ( "." m:ModuleComponent { AC($$, m); })*
ModuleComponent <- Identifier { $$ = CT(MODULE_COMPONENT, $0); }
ImportedNames <- m:ImportedName { $$ = CN(IMPORTED_NAMES, 1, m); } (_ "," _ m:ImportedName { AC($$, m); })*
ImportedName <- Identifier { $$ = CT(IMPORTED_NAME, $0); }

#
# Alias definition
#

AliasDef <- "alias" _ n:Name ("<" _ tv:TypeVariables _ ">")? _ "=" _ t:Type { $$ = CN(ALIAS_DEF, 3, n, tv, t); }

#
# Type definition
#

TypeDef <- "type" _ n:Name ("<" _ t:TypeVariables _ ">")? _ "=" _ tc:TypeConstructors { $$ = CN(TYPE_DEF, 3, n, t, tc); }
TypeConstructors <- t:TypeConstructor { $$ = CN(TYPE_CONSTRUCTORS, 1, t); } (_ "or" _ t:TypeConstructor { AC($$, t); })*
TypeConstructor <- n:Name ("<" _ t:Types _ ">")? { $$ = CN(TYPE_CONSTRUCTOR, 2, n, t); }

#
# Enumeration definition
#

EnumDef <- "enum" __ ed:EnumDefName _ "{" _ e:Enums _ "}" { $$ = CN(ENUM_DEF, 2, ed, e); }
EnumDefName <- Identifier { $$ = CT(ENUM_DEF_NAME, $0); }
Enums <- e:Enum { $$ = CN(ENUMS, 1, e); } (__ e:Enum { AC($$, e); } / EnumValueError)*
Enum <- en:EnumName (_ "=" _ e:Expr)? { $$ = CN(ENUM, 2, en, CN(ENUM_VALUE, 1, e)); }
EnumName <- Identifier { $$ = CT(ENUM_NAME, $0); }
EnumValueError <- ("," / ";") {
    panic("Unexpected %s between enum values on line %d", $0, auxil->row);
}

#
# Function definition
#

FunctionDef <- e:Export? _ "fn" __ f:FunctionName ("<" _ tv:TypeVariables _ ">")? _ "(" _ p:Params? _ ")" _ ("is" _ t:Type _)? b:BlockExpr { ast_node_t* rt = NULL; if (t != NULL) { rt = CN(RETURN_TYPE, 1, t); } $$ = CN(FUNCTION_DEF, 6, e, f, tv, p, rt, b); }
Export <- "export" { $$ = CT(EXPORT, NULL); }
FunctionName <- Identifier { $$ = CT(FUNCTION_NAME, $0); }
Params <- n:NonDefaultParams _ "," _ d:DefaultParams { $$ = CN(PARAMS, 2, n, d); } /
          n:NonDefaultParams { $$ = n; } /
          d:DefaultParams { $$ = d; }
NonDefaultParams <- n:NonDefaultParam { $$ = CN(NON_DEFAULT_PARAMS, 1, n); }
                    (_ "," _ n:NonDefaultParam { AC($$, n); })*
NonDefaultParam <- n:Name (_ "is" _ t:Type)? !(_ "=") { $$ = RN(n, PARAM_NAME); AC($$, t);}
DefaultParams <- d:DefaultParam { $$ = CN(DEFAULT_PARAMS, 1, d); } (_ "," _ d:DefaultParam {AC($$, d); })*
DefaultParam <- i:DefaultParamName (_ "is" _ t:Type { AC(i, t); })? _ "=" _ m:ParamExpr { $$ = CN(DEFAULT_PARAM, 2, i, m); }
DefaultParamName <- Identifier { $$ = CT(PARAM_NAME, $0); }
ParamExpr <- (m:MatchLiteral / m:Name) { $$ = m; }
BlockExpr <- "{" _ b:BlockLevelExprs _ "}" { $$ = b; }
BlockLevelExprs <- b:BlockLevelExpr { $$ = CN(BLOCK_EXPR, 1, b); } (_ Comma _ b:BlockLevelExpr { AC($$, b); })*
BlockLevelExpr <- (b:FunctionDef / b:Expr) { $$ = b; }
Comma <- "," / ";" {
    panic("Unexpected ';' on line %d (use ',' as a separator between "
          "expressions)", auxil->row);
}
Args <- (a:PositionalArgs / a:NamedArgs) { $$ = a; }
PositionalArgs <- !NamedArg e:Expr { $$ = CN(POSITIONAL_ARGS, 1, e); } (_ "," _ e:Expr { AC($$, e); })*
NamedArgs <- n:NamedArg { $$ = CN(NAMED_ARGS, 1, n); } (_ "," _ n:NamedArg { AC($$, n); })*
NamedArg <- n:Name _ ":" _ r:Expr { $$ = CN(NAMED_ARG, 2, n, r); }

#
# Interface definition
#

InterfaceDef <- "interface" __ i:InterfaceName ("<" _ t:TypeVariables _ ">")? _ "{" _
                 im:InterfaceMembers _
                 "}" { $$ = CN(INTERFACE_DEF, 3, i, t, im); }
InterfaceName <- Identifier { $$ = CT(INTERFACE_NAME, $0); }
InterfaceMembers <- i:InterfaceMember { $$ = CN(INTERFACE_MEMBERS, 1, i); } (_ i:InterfaceMember { AC($$, i); } / InterfaceMemberError)*
InterfaceMember <- (i:InterfaceConstructor / i:InterfaceDestructor / i:InterfaceMemberMethod / i:InterfaceMemberProperty) { $$ = i; }
InterfaceConstructor <- "this" _ "(" _ p:Params? _ ")" (_ "is" _ t:Type)? { $$ = CN(INTERFACE_CONSTRUCTOR, 2, p, t); }
InterfaceDestructor <- "~this" _ "(" _ p:Params? _ ")" (_ "is" _ t:Type)? { $$ = CN(INTERFACE_DESTRUCTOR, 3, p, t); }
InterfaceMemberMethod <- m:MemberAccess _ i:InterfaceMethod { $$ = CN(INTERFACE_MEMBER_METHOD, 2, m, i); }
InterfaceMethod <- "fn" _ f:FunctionName ("<" _ tv:TypeVariables _ ">")? _ "(" _ p:Params? _ ")" _  ("is" _ t:Type _)? { $$ = CN(INTERFACE_METHOD, 4, f, tv, p, t); }
InterfaceMemberProperty <- ((m:MemberAccess (_ c:Const)? / c:Readonly) _ n:Name  (_ "is" _ t:Type { AC(n, t); })?) { $$ = CN(INTERFACE_MEMBER_PROPERTY, 4, m, c, n, t); }
InterfaceMemberError <- ("," / ";") {
    panic("Unexpected %s between members on line %d", $0, auxil->row);
}

#
# Class definition
#

ClassDef <- "class" __ cn:ClassName ("<" _ t:TypeVariables _ ">")? _ ( "implements" _ i:Interfaces _ )? "{" _
            c:ClassMembers _
            "}" { $$ = CN(CLASS_DEF, 4, cn, t, i, c); }
ClassName <- Identifier { $$ = CT(CLASS_NAME, $0); }
Interfaces <- i:Interface { $$ = CN(INTERFACES, 1, i); } (_ "," _ i:Interface { AC($$, i); })*
Interface <- n:Name ("<" _ t:Types _ ">")? { $$ = CN(INTERFACE, 2, n, t); }
ClassMembers <- c:ClassMember { $$ = CN(CLASS_MEMBERS, 1, c); } (_ c:ClassMember { AC($$, c); } / ClassMemberError)*
ClassMember <- (c:Constructor / c:Destructor / c:MemberMethod / c:MemberProperty) { $$ = c; }
Constructor <- "this" _ "(" _ p:Params? _ ")" (_ "is" _ t:Type)? _ b:BlockExpr { $$ = CN(CLASS_CONSTRUCTOR, 3, p, t, b); }
Destructor <- "~this" _ "(" _ p:Params? _ ")" (_ "is" _ t:Type)? _ b:BlockExpr { $$ = CN(CLASS_DESTRUCTOR, 3, p, t, b); }
MemberMethod <- m:MemberAccess _ f:FunctionDef { $$ = CN(MEMBER_METHOD, 2, m, f); }
MemberAccess <- "public" { $$ = CT(PUBLIC, NULL); } / "private" { $$ = CT(PRIVATE, NULL); }
MemberProperty <- ((m:MemberAccess (_ c:Const)? / c:Readonly) _ n:Name (_ "is" _ t:Type { AC(n, t); })? (_ "=" _ e:Expr)?) { $$ = CN(MEMBER_PROPERTY, 4, m, c, n, e); }
ClassMemberError <- ("," / ";") {
    panic("Unexpected %s between members on line %d", $0, auxil->row);
}
Const <- "const" { $$ = CT(CONST, NULL); }
Readonly <- "readonly" { $$ = CT(READONLY, NULL); }

#
# Type
#

Types <- t:Type { $$ = CN(TYPES, 1, t); } (_ "," _ t:Type { AC($$, t); })*
Type <- (t:BasicType / t:ListType / t:FunctionType / t:TupleType / t:MapType / t:ConstructorType / t:TypeVariable) { $$ = t; }
BasicType <- (b:BoolType / b:IntType / b:FloatType / b:StringType / b:JobType / b:ChannelType) { $$ = b;}
BoolType <- "Bool" { $$ = CT(BOOL_TYPE, NULL); }
IntType <- "Int" { $$ = CT(INT_TYPE, NULL); }
FloatType <- "Float" { $$ = CT(FLOAT_TYPE, NULL); }
StringType <- "String" { $$ = CT(STRING_TYPE, NULL); }
JobType <- "Job" { $$ = CT(JOB_TYPE, NULL); }
ChannelType <- "Channel" { $$ = CT(CHANNEL_TYPE, NULL); }
ListType <- "[" _ t:Type _ "]" {$$ = CN(LIST_TYPE, 1, t); }
FunctionType <- "(" _ a:Type? _ "->" _ r:Type _ ")" { $$ = CN(FUNCTION_TYPE, 2, CN(ARG_TYPES, 1, a), r); } / "(" _ "{" _ a:ArgTypes _ "}" _ "->" _ r:Type _ ")" { $$ = CN(FUNCTION_TYPE, 2, a, r); }
ArgTypes <- a:Type { $$ = CN(ARG_TYPES, 1, a); } (_ "," _ a:Type { AC($$, a); })*
TupleType <- "(" _ t:Type { $$ = CN(TUPLE_TYPE, 1, t); } (_ "," _ t:Type { AC($$, t); })* _ ")"
MapType <- "[" _ k:Type _ ":" _ v:Type _ "]" { $$ = CN(MAP_TYPE, 2, k, v); }
ConstructorType <- n:Name ("<" _ t:Types _ ">")? { $$ = CN(CONSTRUCTOR_TYPE, 2, n, t); }
TypeVariables <- t:TypeVariable {$$ = CN(TYPE_VARIABLES, 1, t); } (_ "," _ t:TypeVariable { AC($$, t); })*
TypeVariable <- "$" Identifier { $$ = CT(TYPE_VARIABLE, $0); }

#
# Expression
#

Expr <- e:BindExpr { $$ = e; }
BindExpr <- l:MatchExpr _ ":=" _ r:Expr { $$ = CN(BIND, 2, l, r); } / e:LogicalOrExpr { $$ = e; }
LogicalOrExpr <- l:LogicalOrExpr _ "||" _ r:LogicalAndExpr { $$ = CN(OR, 2, l, r); } / e:LogicalAndExpr { $$ = e; }
LogicalAndExpr <- l:LogicalAndExpr _ "&&" _ r:BitwiseAndExpr { $$ = CN(AND, 2, l, r); } / e:BitwiseAndExpr { $$ = e; }
BitwiseAndExpr <- l:BitwiseAndExpr _ "&" _ r:BitwiseOrExpr { $$ = CN(BITWISE_AND, 2, l, r); } / e:BitwiseOrExpr { $$ = e; }
BitwiseOrExpr <- l:BitwiseOrExpr _ "|" _ r:GTEIntExpr { $$ = CN(BITWISE_OR, 2, l, r); } / e:GTEIntExpr { $$ = e; }
GTEIntExpr <- l:GTEIntExpr __ ">Int=" __ r:GTEFloatExpr { $$ = CN(GTE_INT, 2, l, r); } / e:GTEFloatExpr { $$ = e; }
GTEFloatExpr <- l:GTEFloatExpr __ ">Float=" __ r:GTIntExpr { $$ = CN(GTE_FLOAT, 2, l, r); } / e:GTIntExpr { $$ = e; }
GTIntExpr <- l:GTIntExpr __ ">Int>" __ r:GTFloatExpr { $$ = CN(GT_INT, 2, l, r); } / e:GTFloatExpr { $$ = e; }
GTFloatExpr <- l:GTFloatExpr __ ">Float>" __ r:LTEIntExpr { $$ = CN(GT_FLOAT, 2, l, r); } / e:LTEIntExpr { $$ = e; }
LTEIntExpr <- l:LTEIntExpr __ "<Int=" __ r:LTEFloatExpr { $$ = CN(LTE_INT, 2, l, r); } / e:LTEFloatExpr { $$ = e; }
LTEFloatExpr <- l:LTEFloatExpr __ "<Float=" __ r:LTIntExpr { $$ = CN(LTE_FLOAT, 2, l, r); } / e:LTIntExpr { $$ = e; }
LTIntExpr <- l:LTIntExpr __ "<Int<" __ r:LTFloatExpr { $$ = CN(LT_INT, 2, l, r); } / e:LTFloatExpr { $$ = e; }
LTFloatExpr <- l:LTFloatExpr __ "<Float<" __ r:NotEqualExpr { $$ = CN(LT_FLOAT, 2, l, r); } / e:NotEqualExpr { $$ = e; }
NotEqualExpr <- l:NotEqualExpr _ "!" t:Name "=" _ r:EqualExpr { $$ = CN(NE, 3, l, t, r); } / e:EqualExpr { $$ = e; }
EqualExpr <- l:EqualExpr _ "=" t:Name "=" _ r:InExpr { $$ = CN(EQ, 3, l, RN(t, EQ_TYPE), r); } / e:InExpr { $$ = e; }
InExpr <- l:InExpr _ "in" _ e:RightShiftExpr { $$ = CN(IN, 2, l, e); } / e:RightShiftExpr { $$ = e; }
RightShiftExpr <- l:RightShiftExpr __ ">>" __ e:LeftShiftExpr { $$ = CN(BSR, 2, l, e); } / e:LeftShiftExpr { $$ = e; }
LeftShiftExpr <- l:LeftShiftExpr __ "<<" __ e:ConsExpr { $$ = CN(BSL, 2, l, e); } / e:ConsExpr { $$ = e; }
ConsExpr <- l:ConsExpr _ "::" _ r:ListConcatExpr { $$ = CN(CONS, 2, l, r); } / e:ListConcatExpr { $$ = e; }
ListConcatExpr <- l:ListConcatExpr _ "@" _ r:MapConcatExpr { $$ = CN(CONCAT_LIST, 2, l, r); } / e:MapConcatExpr { $$ = e; }
MapConcatExpr <- l:MapConcatExpr _ "~" _ r:StringConcatExpr { $$ = CN(CONCAT_MAP, 2, l, r); } / e:StringConcatExpr { $$ = e; }
StringConcatExpr <- l:StringConcatExpr _ "^" _ r:MinusIntExpr { $$ = CN(CONCAT_STRING, 2, l, r); } / e:MinusIntExpr { $$ = e; }
MinusIntExpr <- l:MinusIntExpr _ "-" _ r:MinusFloatExpr { $$ = CN(MINUS_INT, 2, l, r); } / e:MinusFloatExpr { $$ = e; }
MinusFloatExpr <- l:MinusFloatExpr _ "-." _ r:PlusIntExpr { $$ = CN(MINUS_FLOAT, 2, l, r); } / e:PlusIntExpr { $$ = e; }
PlusIntExpr <- l:PlusIntExpr _ "+" _ r:PlusFloatExpr { $$ = CN(PLUS_INT, 2, l, r); } / e:PlusFloatExpr { $$ = e; }
PlusFloatExpr <- l:PlusFloatExpr _ "+." _ r:ModulusExpr { $$ = CN(PLUS_FLOAT, 2, l, r); } / e:ModulusExpr { $$ = e; }
ModulusExpr <- l:ModulusExpr _ "%" _ r:DivideIntExpr { $$ = CN(MODULUS, 2, l, r); } / e:DivideIntExpr { $$ = e; }
DivideIntExpr <- l:DivideIntExpr _ "/" _ r:DivideFloatExpr { $$ = CN(DIVIDE_INT, 2, l, r); } / e:DivideFloatExpr { $$ = e; }
DivideFloatExpr <- l:DivideFloatExpr _ "/." _ r:MultiplyIntExpr { $$ = CN(DIVIDE_FLOAT, 2, l, r); } / e:MultiplyIntExpr { $$ = e; }
MultiplyIntExpr <- l:MultiplyIntExpr _ "*" _ r:MultiplyFloatExpr { $$ = CN(MULTIPLY_INT, 2, l, r); } / e:MultiplyFloatExpr { $$ = e; }
MultiplyFloatExpr <- l:MultiplyFloatExpr _ "*." _ r:ExponentiationExpr { $$ = CN(MULTIPLY_FLOAT, 2, l, r); } / e:ExponentiationExpr { $$ = e; }
ExponentiationExpr <- l:ExponentiationExpr _ "^^" _ r:NotExpr { $$ = CN(EXPONENTIATE, 2, l, r); } / e:NotExpr { $$ = e; }
NotExpr <- "!" _ l:UnaryPlusIntExpr { $$ = CN(NOT, 1, l); } / e:UnaryPlusIntExpr { $$ = e; }
UnaryPlusIntExpr <- "+" _ l:UnaryPlusFloatExpr { $$ = CN(UNARY_PLUS_INT, 1, l); } / e:UnaryPlusFloatExpr { $$ = e; }
UnaryPlusFloatExpr <- "+." _ l:UnaryMinusIntExpr { $$ = CN(UNARY_PLUS_FLOAT, 1, l); } / e:UnaryMinusIntExpr { $$ = e; }
UnaryMinusIntExpr <- "-" _ l:UnaryMinusFloatExpr { $$ = CN(UNARY_MINUS_INT, 1, l); } / e:UnaryMinusFloatExpr { $$ = e; }
UnaryMinusFloatExpr <- "-." _ l:PostfixExpr { $$ = CN(UNARY_PLUS_FLOAT, 1, l); } / e:PostfixExpr { $$ = e; }
PostfixExpr <- (p:PrimaryExpr { $$ = CN(POSTFIX_EXPR, 1, p); }
                (_ "." _ n:Name { AC($$, RN(n, DOT_NAME)); } /
                 _ "[" _ s:Expr _ ".." _ e:Expr _ "]" { AC($$, CN(LIST_SLICE, 2, s, e)); } /
                 _ "[" _ i:IndexValues _ "]" { AC($$, CN(LIST_UPDATE, 1, i)); } /
                 _ "[" _ m:MapKeyValues _ "]" { AC($$, CN(MAP_UPDATE, 1, m)); } /
                 _ "[" _ e:Expr _ "]" { AC($$, CN(LIST_LOOKUP, 1, e)); } /
                 _ ("<" _ e:Expr _ ">")? "(" _ a:Args? _ ")" { AC($$, CN(FUNCTION_CALL, 2, e, a)); })*)

IndexValues <- i:IndexValue { $$ = CN(INDEX_VALUES, 1, i); } (_ "," _ i:IndexValue { AC($$, i); })*
IndexValue <- i:Int _ "=" _ v:Expr { $$ = CN(INDEX_VALUE, 2, i, v); }

PrimaryExpr <- "nil" { $$ = CT(NIL, NULL); } /
               "this" { $$ = CT(THIS, NULL); } /
               "self" { $$ = CT(SELF, NULL); } /
               "$" { $$ = CT(SLICE_LENGTH, NULL); } /
               e:ControlFlowExpr { $$ = e; } /
               e:Literal { $$ = e; } /
               e:Name { $$ = e; } /
               "(" _ e:Expr _ ")" { $$ = e; }

ControlFlowExpr <- (c:IfExpr / c:CaseExpr / c:ReceiveExpr / c:BlockExpr) { $$ = c; }

IfExpr <- "if" __ ie:Expr _ b:BlockExpr { $$ = CN(IF_EXPR, 1, CN(IF, 2, ie, b)); }
          (_ "elif" __ ee:Expr _ b:BlockExpr { AC($$, CN(ELIF, 2, ee, b)); })*
          (_ "else" _ e:BlockExpr { AC($$, CN(ELSE, 1, e)); })

CaseExpr <- "case" __ e:Expr { $$ = CN(CASE_EXPR, 1, CN(CASE, 1, e)); } _ "{"
              (_ m:MatchExprs _ ("when" _ we:Expr { AC($$, CN(WHEN, 1, we)); } _)? _ b:BlockExpr { AC($$, CN(CASE_BRANCH, 2, m, b)); })+
              (_ "default" _ b:BlockExpr { AC($$, CN(DEFAULT, 1, b)); })? _
              "}"

ReceiveExpr <- "receive" __ c:ReceiveChannels { $$ = CN(RECEIVE_EXPR, 1, CN(RECEIVE, 1, c)); } (_ "{"
               (_ m:MatchExprs _ b:BlockExpr _ { AC($$, CN(CASE, 2, m, b)); })+
               (_ "timeout" _ d:DecimalInt _ b:BlockExpr { AC($$, CN(TIMEOUT, 2, d, b)); })? _
               "}")?

ReceiveChannels <- (c:Channel / "[" _ c:Channels _ "]") { $$ = c; }
Channel <- (c:ChannelName { $$ = CN(CHANNEL, 1, c); }
                (_ "." _ n:Name { AC($$, RN(n, DOT_NAME)); } /
                 _ "[" _ e:Expr _ "]" { AC($$, CN(LIST_LOOKUP, 1, e)); })*)
ChannelName <- Identifier { $$ = CT(CHANNEL_NAME, $0); }
Channels <- c:Channel { $$ = CN(CHANNELS, 1, c); } (_ "," _ c:Channel { AC($$, c); })*

Literal <- (l:BasicLiteral / l:CompositeLiteral) { $$ = l; }

BasicLiteral <- (b:BoolLiteral / b:NumberLiteral / b:CharLiteral /
                 b:StringLiteral / b:FunctionLiteral / b:EnumLiteral) { $$ = b; }

CompositeLiteral <- (c:TupleLiteral / c:ListLiteral / c:MapLiteral / c:TypeConstructorLiteral) { $$ = c; }

BoolLiteral <- "true" { $$ = CT(TRUE, NULL); } / "false" { $$ = CT(FALSE, NULL); }

NumberLiteral <- (n:Float / n:Int) { $$ = n; }

Float <- (f:DecimalPointLeading / f:DecimalPointTrailing) { $$ = CT(FLOAT, $0); }
DecimalPointLeading <- [0-9]* "." [0-9]+ ExponentPart?
DecimalPointTrailing <- [0-9]+ ExponentPart
ExponentPart <- [eE] [+-]? [0-9]+

Int <- (HexInt / BinaryInt / OctalInt / DecimalInt) { $$ = CT(INT, $0); }
HexInt <- "0x" [0-9a-fA-F]+
BinaryInt <- "0b" [01]+
OctalInt <- "0" [0-7]+
DecimalInt <- [0-9]+

CharLiteral <- "'" (c:EscapeChar / c:NonQuoteChar) "'" { $$ = CN(CHARACTER_LITERAL, 1, c); }
EscapeChar <- "\\" (
              [abfnrtv'"\\] /
              "x" HexDigit HexDigit /
              "u" HexDigit HexDigit HexDigit HexDigit /
              "U" HexDigit HexDigit HexDigit HexDigit
                  HexDigit HexDigit HexDigit HexDigit /
               OctalDigit /
               OctalDigit OctalDigit /
               OctalDigit OctalDigit OctalDigit
               ) { $$ = CT(ESCAPE_CHARACTER, $0); }
HexDigit <- [0-9a-fA-F]
OctalDigit <- [0-7]
NonQuoteChar <- [^'] { $$ = CT(NON_QUOTE_CHARACTER, $0); }

StringLiteral <- ('"' s:RegularString '"' / 'r"' s:RawString '"') { $$ = s; }
RegularString <- (EscapeSequence / [^"])* { $$ = CT(REGULAR_STRING, $0); }
EscapeSequence <- "\\" [btnvfr"\\]
RawString <- [^"]* { $$ = CT(RAW_STRING, $0); }

FunctionLiteral <- "fn" _ "(" _ p:Params? _ ")" _ e:BlockExpr { $$ = CN(FUNCTION_LITERAL, 2, p, e); }

EnumLiteral <- edn:EnumDefName _ "#" _ en:EnumName { $$ = CN(ENUM_LITERAL, 2, edn, en); }

TupleLiteral <- "(" _ ")" { $$ = CT(TUPLE_LITERAL, NULL); } / "(" _ e:TupleExprs _ ")" { $$ = RN(e, TUPLE_LITERAL); }
TupleExprs <- e1:Expr _ "," _ e2:Expr { $$ = CN(EXPRS, 2, e1, e2); } (_ "," _ e:Expr { AC($$, e); })*

ListLiteral <- "[" _ "]" { $$ = CT(LIST_LITERAL, NULL); } / "[" _ e:Exprs? _ "]" { $$ = RN(e, LIST_LITERAL); }
Exprs <- e:Expr { $$ = CN(EXPRS, 1, e); } (_ "," _ e:Expr { AC($$, e); })*

MapLiteral <- "[:]" { $$ = CT(MAP_LITERAL, NULL); } / "[" _ k:MapKeyValues? _ "]" { $$ = RN(k, MAP_LITERAL); }
MapKeyValues <- m:MapKeyValue { $$ = CN(MAP_KEY_VALUES, 1, m); } (_ "," _ m:MapKeyValue { AC($$, m); })*
MapKeyValue <- (k:Literal / k:Name) _ ":" _ v:Expr { $$ = CN(MAP_KEY_VALUE, 2, k, v); }

TypeConstructorLiteral <- n:Name "<" _ e:Exprs _ ">" { $$ = CN(TYPE_CONSTRUCTOR_LITERAL, 2, n, e); }

#
# Match expression
#

MatchExpr <- (m:MatchCons / m:MatchLiteral / (m:UnboundName (_ "is" _ t:Type { AC(m, t); })?) / m:Name) { $$ = m; } (_ "as" _ u:UnboundName { AC($$, RN(u, MATCH_AS)); })?

MatchCons <- l:MatchExpr _ "::" _ r:MatchExpr { $$ = CN(CONS, 2, l, r); }

MatchLiteral <- (m:MatchBasicLiteral / m:MatchCompositeLiteral) { $$ = m; }

MatchBasicLiteral <- (m:BoolLiteral /
                      m:NumberLiteral /
                      m:CharLiteral /
                      m:StringLiteral /
                      m:EnumLiteral) { $$ = m; }

MatchCompositeLiteral <- (m:MatchTupleLiteral /
                          m:MatchListLiteral /
                          m:MatchMapLiteral /
                          m:MatchClassLiteral /
                          m:MatchTypeConstructorLiteral) { $$ = m; }

MatchTupleLiteral <- "(" _ ")" { $$ = CT(TUPLE_LITERAL, NULL); } / "(" _ m:MatchTupleExprs _ ")" { $$ = RN(m, TUPLE_LITERAL); }
MatchTupleExprs <- m1:MatchExpr _ "," _ m2:MatchExpr { $$ = CN(MATCH_EXPRS, 2, m1, m2); } (_ "," _ m:MatchExpr { AC($$, m); })*

MatchListLiteral <- "[" _ "]" { $$ = CT(LIST_LITERAL, NULL); } /
                    n:Name "[" _ m:MatchExpr? _ "]" { $$ = CN(LIST_LOOKUP, 2, n, m); } /
                    "[" _ m:MatchExprs? _ "]" { $$ = RN(m, LIST_LITERAL); }
MatchExprs <- m:MatchExpr { $$ = CN(MATCH_EXPRS, 1, m); } (_ "," _ m:MatchExpr { AC($$, m); })*

MatchMapLiteral <- "[:]" { $$ = CT(MAP_LITERAL, NULL); } / "[" _ m:MatchMapKeyValues? _ "]" { $$ = RN(m, MAP_LITERAL); }
MatchMapKeyValues <- m:MatchMapKeyValue { $$ = CN(MAP_KEY_VALUES, 1, m); } (_ "," _ m:MatchMapKeyValue { AC($$, m); })*
MatchMapKeyValue <- (k:Literal / k:Name) _ ":" _ v:MatchExpr { $$ = CN(MAP_KEY_VALUE, 2, k, v); }

MatchClassLiteral <- n:Name _ "(" _ m:NamedMatchArgs _ ")" { $$ = CN(MATCH_CLASS_LITERAL, 2, n, m); }
NamedMatchArgs <- n:NamedMatchArg { $$ = CN(NAMED_MATCH_ARGS, 1, n); } (_ "," _ n:NamedMatchArg { AC($$, n); })*
NamedMatchArg <- u:UnboundName { $$ = CN(NAMED_MATCH_ARG, 1, u); } / n:Name _ ":" _ r:MatchExpr { $$ = CN(NAMED_MATCH_ARG, 2, n, r); }

MatchTypeConstructorLiteral <- n:Name "<" _ m:MatchExprs _ ">" { $$ = CN(MATCH_TYPE_CONSTRUCTOR_LITERAL, 2, n, m); }

#
# Misc
#

Identifier <- [a-zA-Z_][a-zA-Z_0-9_]*
Name <- Identifier { $$ = CT(NAME, $0); }
UnboundName <- "?" n:Name { $$ = RN(n, UNBOUND_NAME); } / "_" { $$ = CT(UNBOUND_NO_NAME, $0); }
#_ <- WS*
#__ <- WS+
_ <- (WS / Comments)*
__ <- (WS / Comments)+
WS <- [ \t\r\n] {
    if ($0[0] == '\n') {
        auxil->row++;
    }
}
Comments <- SingleLineComment / BlockComment
SingleLineComment <- "//" (!EOL .)* EOL?
EOL <- ("\r\n" / "\n" / "\r") { auxil->row++; }
BlockComment <- "/*" (BlockCommentContent / EOL)* "*/"
BlockCommentContent <- (!("*/" / EOL) .)
EOF <- _ !.

%%
int main() {
#ifdef UNITTEST
    symbol_table_unit_test();
#endif
    /*
     * Parse source
     */
    satie_auxil_t* satie_auxil = satie_auxil_new();
    satie_context_t *context = satie_create(satie_auxil);
    ast_node_t* program;
    satie_parse(context, &program);
    //ast_print(program, 0);
    /*
     * Check semantics
     */
    satie_error_t error;
    if (!hm_infer_types(program, &error)) {
       fprintf(stderr, "Error: %s\n", satie_error_message);
       return 1;
    }
    /*
     * Cleanup
     */
    satie_destroy(context);
    return 0;
}
