
Hmm, jag skule kunna krypa till korset och säga att jag har samma
anropskonvention som D och mycket liknande semantik som D.

Jag skulle då låta const vara något som måste vara en compile time
resolverbar konstant så slipper det grumla vattnet.

Operatorn = blir en match operator på samma sätt som i Erlang
(troligen är det lätt förvirrande att använda = till detta)

@a refererar till tidigare bunden variabel a (jmf pinning operator)

#(1, 2) är en tupel

Rad-scope

Under dessa förutsättningar tror jag kodsnutten nedan förklarar sig
själv.

Inte för att du alls tycker om detta men det är varken mer eller
mindre osunt än D vad jag kan se. Lika dåligt antar jag att du
tycker. :-)

fn main() {
    ?a = [1, 2],       // Compile time constant (must be resolvable at runtime)
    ?b = a,                  // Copy
    ?b = b,                 // @b refer to the earlier bound b (obviously always true)
    ?b = #(a, b),            // Destructive
    b == #([1, 2], [1, 2]), // true
    ?c = [1, 2],
    #(?d, c) = b,
    d == [1, 2]             // true
    ?e = match b {
      #(?a, c) {
        a
      }
    },
    ?f = foo(a, b, c, d);
    a == [1, 2],         // true
    b == [1, 666],       // true
    c == 42,             // true
    d == [1, 2],         // true
    e == [1, 2],         // true
    f == 4711            // true
}

fn foo(a, b, c, d) {
    b[1] = 666,
    a = 4711
}
