export fn test() {
    // Create record and calculate a few values in the local process context
    ?ackermann := new Ackermann(),
    (?x, ?ackermann) := ackermann.calc(3, 12),
    writeln("Ackermann(3, 12) = %x"),
    (?y, ?ackermann) := ackermann.calc(3, 13),
    writeln("Ackermann(3, 13) = %y"),
    writeln("Saved calculations: %{ackermann.savedCalculations}"),
    ?ackermann := ackermann.resetCalculatedValues(),

    // Create a task from the already existing and calculate the same values
    // in another process context
    ?task := launch ackermann,
    (x, task) := task<->calc(3, 12),
    writeln("Ackermann(3, 12) = %x"),
    (y, task) := task<->calc(3, 13),
    writeln("Ackermann(3, 13) = %y"),
    writeln("Saved calculations: %{task<->savedCalculations}"),
    task := task<->resetCalculatedValues(),

    // etc

    // Maybe it should be possible to cast as well (not waiting for a result)
    task->resetCalculatedValues()
}

record Ackermann {
    public savedCalculations is (Int, Int, Int) = []
    public fn calc(m, n) {
        ?result := ackermann(m, n),
        (result, this(savedCalculations: (m, n, result) :: savedCalculations))
    }
    public fn resetCalculatedValues() {
        this(savedCalculatedValues: [])
    }
    private fn ackermann(m, n) {
        if m =Int= 0 {
            n + 1
        } elif n =Int= 0 {
            ackermann(m - 1, 1)
        } else {
            ackermann(m - 1, ackermann(m, n - 1))
        }
    }
}
