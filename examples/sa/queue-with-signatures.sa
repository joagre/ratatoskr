type Result(Value, Reason) = Ok(Value) or Error(Reason)

enum ErrorStatus {
   emptyQueue
}

interface QueueInterface(T) {
    this(element : T) : QueueInterface(T)
    public fn enqueue(element : T) : QueueInterface(T)
    public fn null() : Bool
    public fn hd() : Result(T, ErrorStatus)
    public fn dequeue() : Result(QueueInterface(T), ErrorStatus)
}

class Queue(T) implements QueueInterface(T) {
    private queue : [T]

    this(element) {
        this(queue: [element])
    }

    public fn enqueue(element) {
        this(queue: queue @ [element])
    }

    public fn null() {
        queue.isEmpty()
    }

    public fn hd() {
        case queue {
            [] { Result:Error(ErrorStatus#emptyQueue) }
            [?first :: _] { Result:Ok(first) }
        }
    }

    public fn dequeue() {
        case queue {
            [] { Result:Error(ErrorStatus#emptyQueue) }
            [_ :: ?rest] { Result:Ok(this(queue: rest)) }
        }
    }
}

export fn main(_args) {
    ?a := Queue(Float)(0.1),
    ?a1 := Queue(0.1), // the Float type can be left out in this case
    ?b := a.enqueue(3.14),
    Result:Ok(0.1) := b.hd()
}
