import std.satie
import std.stdio: writeln

export fn main(args) {
    ?numberOfTributes := args[1],
    ?channel := satie.makeChannel(copies: numberOfTributes),
    ?jobs := startTributes(channel, numberOfTributes),
    channel.send("Standing on the shoulders of ${jobs.length} giants")
}

fn startTributes(channel, numberOfTributes, n = 0, jobs = []) {
    if n < numberOfTributes {
        ?job := satie.spawn(fn () {
                    ?message := receive channel,
                    writeln("$n: $message")
                }),
        startTributes(channel, numberOfTributes, n + 1, job @ jobs)
    } else {
        jobs
    }
}

/*
A channel can be created with the following modifiers:

copies: N
    Keep a message in the mailbox until N instances has read it
fade: N
    If a message hasn't been read in N milliseconds it fades away
sync: Bool
    Should the sender block until the receiver has read the message
    (defaults to false)?
size: (Type, Size)
    Set the number of messages allowed in a channel to Size. If this
    threshold is reached the sender blocks or the message is ignored,
    depending on Type (which can either be the enum
    ChannelOption@block or ChannelOption@ignore).
*/









type Compare(T) = (T, T) -> Bool
type Result(T) = Success(T) or Error(String)



fn sort(c is Compare(T), l is List[T]) is Result(List[T]) {
    if l.isEmpty() {
        Error("Empty List")
    } else {
        Success(qsort(c, l))
    }
}

fn qsort(c is Compare(T), l is List[T]) is List[T] {
    switch l {
        case []:
            []
        case ?x :: ?xs:
            (?smaller, ?larger) := l.partition(fn (y) { c(y, x) }, xs),
            qsort(smaller @ [x] @ qsort(larger))
    }
}
