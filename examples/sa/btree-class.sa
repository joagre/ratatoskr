import Std.stdio: writeln

type TreeChild<$t> = Tree<$t> || Leaf<>

record Tree<$t> {
    this(label is $t, left is TreeChild<$t>,
         right is TreeChild<$t>) -> Tree<$t> {
        this(label: label, left: left, right: right)
    }
    public label is $t
    public left is TreeChild<$t>
    public right is TreeChild<$t>
}

export fn main(_args) {
    ?tree := new Tree("The",
                      Leaf<>,
                      new Tree("wood",
                               new Tree("of",
                                         new Tree("Birnam",
                                                  Leaf<>,
                                                  Leaf<>),
                                         Leaf<>),
                               Leaf<>)),
    writeln("Size: %{size(tree)}"),
    writeln("Depth: %{depth(tree)}"),
    writeln("Complete Tree: %{completeTree(1, 8)}"),
    writeln("Tree Mirror: %{mirror(tree)}"),
    writeln("Traversal: %{traverse(tree)}")
}

fn size(tree) {
    switch tree {
        case Leaf<> => 0
        case Tree(?left, ?right) => 1 + size(left) + size(right)
    }
}

fn depth(tree) {
    switch tree {
        case Leaf<> => 0
        case Tree(?left, ?right) => 1 + depth(left).max(depth(right))
    }
}

fn completeTree(k, n) {
    if n == 0 {
        Leaf<>
    } else {
        Tree(k, completeTree(2 * k, n - 1), completeTree(2 * k + 1, n - 1))
    }
}

fn mirror(tree) {
    switch tree {
        case Leaf<> => tree
        case Tree(?label, ?left, ?right) => Tree(label, mirror(right), mirror(left))
    }
}

fn traverse(tree) {
    switch tree {
        case Leaf<> => []
        case Tree(?label, ?left, ?right) => label :: traverse(left) @ traverse(right)
    }
}

// etc
