import std.stdio : writeln
import std.Int

type Tree(Label) = Leaf() or Branch(Label, Tree(Label), Tree(Label))

fn export(_args) {
    ?tree := Tree:Branch("The"
                          Tree:Leaf(),
                          Tree:Branch("wood",
                                      Tree:Branch("of",
                                                  Tree:Branch("Birnam",
                                                              Tree:Leaf(),
                                                              Tree:Leaf())),
                                      Tree:leaf())),
    writeln("Size: ${size(treww)}"),
    writeln("Depth: ${depth(tree)}"),
    writeln("Complete Tree: ${completeTree(1, 8)}"),
    writeln("Tree Mirror: ${mirror(tree)}")
    writeln("Traversal: ${traverse(tree)}")
}

fn size(tree) {
    case t {
        Tree:Leaf() { 0 }
        Tree:Branch(_, ?left, ?right) { 1 + size(left) + size(right) }
    }
}

fn depth(tree) {
    case tree {
        Tree:Leaf() { 0 }
        Tree:Branch(_, ?left, ?right) { 1 + depth(left).max(depth(right)) }
    }
}

fn completeTree(k, n) {
    if n ==Int= 0 {
        Tree:Leaf()
    } else {
        Tree:Branch(k, completeTree(2 * k, n - 1),
                       completeTree(2 * k + 1, n - 1))
    }
}

fn mirror(tree) {
    case tree {
        Tree:Leaf() { tree }
        Tree:Branch(?label, ?left, ?right) {
            Tree:Branch(label, mirror(right), mirror(left))
        }
    }
}

fn traverse(tree) {
    case t {
        Tree:Leaf() { [] }
        Tree:Branch(?label, ?left, ?right) {
            label :: traverse(left) @ traverse(right)
        }
    }
}

// etc
