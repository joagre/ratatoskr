import std.Stdio : writeln

type Tree(Label) = Leaf() or Branch(Label, Tree(Label), Tree(Label))

export fn main(_args) {
    ?tree := Branch("The",
                    Leaf(),
                    Branch("wood",
                           Branch("of",
                                  Branch("Birnam",
                                  Leaf(),
                           Leaf())))),
    writeln("Size: ${size(tree)}"),
    writeln("Depth: ${depth(tree)}"),
    writeln("Complete Tree: ${completeTree(1, 8)}"),
    writeln("Tree Mirror: ${mirror(tree)}")
    writeln("Traversal: ${traverse(tree)}")
}

fn size(tree) {
    case tree {
        Leaf() { 0 }
        Branch(_, ?left, ?right) { 1 + size(left) + size(right) }
    }
}

fn depth(tree) {
    case tree {
        Leaf() { 0 }
        Branch(_, ?left, ?right) { 1 + depth(left).max(depth(right)) }
    }
}

fn completeTree(k, n) {
    if n ==Int= 0 {
        Leaf()
    } else {
        Branch(k, completeTree(2 * k, n - 1), completeTree(2 * k + 1, n - 1))
    }
}

fn mirror(tree) {
    case tree {
        Leaf() { tree }
        Branch(?label, ?left, ?right) {
            Branch(label, mirror(right), mirror(left))
        }
    }
}

fn traverse(tree) {
    case tree {
        Leaf() { [] }
        Branch(?label, ?left, ?right) {
            label :: traverse(left) @ traverse(right)
        }
    }
}

// etc
