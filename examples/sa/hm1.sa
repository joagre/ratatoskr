fn zap() {
   ?a := 1.9,
   a >Float> 2.0
   //1.3 =Float= 1.0

/*
   ?b is [Int: Int] := [1: 2],
   case 1 in b {
       None<> {
           42
       }
       Some<?value> {
           value
       }
   }
*/
}

/*
fn foo(f is (Bool -> Bool), g, x) {
    if f(x =Int= 1) {
        g(x),
        //1 := g(x),
        baz(1)
    } else {
        20
    }
}

fn baz(z) {
    (z, ?a) := (1, 42),
    a
}
*/






/*
fn f(x is Int) is Int {
   x,
   1
}
*/

/*
fn foo() {
   f(1)
}
*/

/*
fn foo() {
   f(1)
}
*/

/*
fn foo(f, g is (Int -> Int), x is Int) {
    ?x := (1, 2),
    x := 1,
    if f(x =Int= 1) {
        ?d := 1,
        g(x)
    } else {
        //d := 1,
        20
    }
}
*/









// t0 -> ({(Bool -> Bool), (Int -> Int), Int} -> Int)

/*
function def + lambda
bind (new symbol table)

blck exprs delimits scope popping

if true {
  (?a, ?d) := (1, 4),
  foo()
  ?b := a + 1
} else {
  2

when going into a block expr, give it a unique id
when going out


fn foo(f is ([Bool] -> Bool),
       g is ([Int] -> Int),
       x is Int) is Int {
*/