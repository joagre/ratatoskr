fn foo(f, g, x) {
    if f(x == 1) {
        g(x)
    } else {
        20
    }
}

fn bar(x, y) {
    ?a := [x: y],
    [?b: y] := a,
    x := b,
    ?a := [:],
    a := [:],
    [y: x]
}

fn foo() {
   [2: [true: false]] := bar([true: false], 2)
}

/*
fn foo() {
    bar([true: false], 2),
}
*/

/*
fn bar(x is [Bool: Bool], y is Int) is [Int: [Bool: Bool]] {
    ?a is [[Bool: Bool]: Int] := [x: y],
    [?b is [Bool: Bool]: y] := a,
    x := b,
    ?a is [:] := [:],
    a := [:],
    [y: x]
}

fn foo() is Bool {
   [2: [true: ?b is Bool]] := bar([true: false], 2),
   b
}
*/
/*
fn bonk(y) {
   ?b := (y, false),
   (?c, true) := b,
   c
}

*/

/*
fn foo(f is (Bool -> Bool), g, x) {
    if f(x =Int= 1) {
        g(x),
        //1 := g(x),
        baz(1)
    } else {
        20
    }
}

fn baz(z) {
    (z, ?a) := (1, 42),
    a
}
*/

/*
fn zap() {
   ?a := 1.9,
   a >Float> 2.0
   //1.3 =Float= 1.0
*/

/*
   ?b is [Int: Int] := [1: 2],
   case 1 in b {
       None<> {
           42
       }
       Some<?value> {
           value
       }
   }
*/







/*
fn f(x is Int) is Int {
   x,
   1
}
*/

/*
fn foo() {
   f(1)
}
*/

/*
fn foo() {
   f(1)
}
*/

/*
fn foo(f, g is (Int -> Int), x is Int) {
    ?x := (1, 2),
    x := 1,
    if f(x =Int= 1) {
        ?d := 1,
        g(x)
    } else {
        //d := 1,
        20
    }
}
*/








// t0 -> ({(Bool -> Bool), (Int -> Int), Int} -> Int)

/*
function def + lambda
bind (new symbol table)

blck exprs delimits scope popping

if true {
  (?a, ?d) := (1, 4),
  foo()
  ?b := a + 1
} else {
  2

when going into a block expr, give it a unique id
when going out


fn foo(f is ([Bool] -> Bool),
       g is ([Int] -> Int),
       x is Int) is Int {
*/