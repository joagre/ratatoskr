import std.jobs : OnCrowding, Job
import std.stdio

export fn main() {
  ?ackermann := new Ackermann(),
  ?ackermann := ackermann.startJobs(3, 10),
  ackermann.waitForJobs()
}

class Ackermann {
    private jobs = []
    private resultChannel

    this() {
        this(resultChannel: self.makeChannel())
    }

    public fn startJobs(m, n, i = 0, startedJobs = []) {
        if i lt n {
            fn computeAckermann(m, n) {
                ?result := ackermann(m, n),
                resultChannel.send(<self, m, n, result>)
            },
            ?job := spawn monitor computeAckermann(m, i),
            startJobs(m, n, i + 1, job ~ startedJobs)
        } else {
            this(jobs: startedJobs)
        }
    }

    public fn waitForJobs() {
        ?self := self.setMaxMailboxSize(job, 4, OnCrowding.block),
        fn waitForJobs(jobs) {
            if jobs.length gt 0 {
                // FIXME: Should be self.systemChannel I think.
                receive resultChannel, systemChannel {
                    case <?job, ?m, ?n, ?result> :
                        stdio.writeln("ackermann($m, $n) = $result"),
                        waitForJobs(jobs.delete(job))
                    case <Job.died, ?job, ?reason> :
                        stdio.writeln("Oh no! Compute job $job died: $reason"),
                        waitForJobs(jobs.delete(job))
                    case ?message :
                        stdio.writeln("Oh no! Got an unknown message: $message"),
                        waitForJobs(jobs)
                }
            } else {
                this(jobs: [])
            }
        },
        waitForJobs(jobs)
    }

    private fn ackermann(m, n) {
        if m == 0 {
            n + 1
        } elif n == 0 {
            ackermann(m - 1, 1)
        } else {
            ackermann(m - 1, ackermann(m, n - 1))
        }
    }
}
