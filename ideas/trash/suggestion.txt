The today discussion
--------------------

* Adorn variables that must be bound with an @ character,
  i.e. @foo. Unbound variables is left unadorned. Test this.

* Update integral description to be less implementatoons
  specific.

* Join structs and jobs into a single job concept. Maybe like this:

Jobs can be spawned the good old way:

spawn fn () {
    fn loop(state) {
        receive {
            case ?incomingMessage {
                loop(state[foo: incomingMessage])
            }
        }
    },
    loop([foo: 42])
}

But a job can also be spawned with a job specification. A job
specification is very similar to the struct construct but it can have
a receive statement as well.

job Foo {
    private foo
    public bar
    public const zonk = 42
    readonly zink

    this(a, b) {
        this(bar: a, zink: b, foo: "basmati")
    }

    public fn filur() {
        if foo == 42 {
           bar
        }
    }

    private fn hasNext() {
        !zink
    }

    receive {                   // Optional
        case incomingMessage {
            this(zink: incomingMessage)
        }
    }
}

The job above specifies an optional receive statement. The receive
statement also has access to all member variables and functions and
can update the member variables with a self referential call to this
(like it does in its constructor).

A job is spawned with a job specification is like this:

pid = spawn thread Foo(42, true)

or

pid = spawn fiber Foo(42, true)

(A fiber runs in the current job's scheduing context)

What can be done with a pid? Maybe this:

pid <| #(self, 42, "bar"),              // send a message
?result = pid.filur()                   // call a member function
pid.filur = "assar"

If job is spawned like a thread both `?result = pid.filur()` and
`pid.filur = "assar"` is implemnted with message passing under the
hood.

If job is spawned like a fiber `?result = pid.filur()` and `pid.filur
= "assar"` can be implemnted without message passing under the hood.

The idea is to formalise and enrich the state in jobs but also let
jobs conceptually be "processes". Beacuse process can have a mutable
state, i.e. like an Erlang process.

Det här är att klyva hår. Men sånt är viktigt. :-)

Känner du rysningar i ryggraden? :-)

/Joakim
